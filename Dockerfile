#* Многоступенчатая сборка Docker
#? 1) Создаём контейнер, выполняем определённый набор инструкций, в этот контейнер мы перенесём весь наш код. Затем запустим ( npm run build ) для компиляции нашего кода в ( js ).

#? 2) Затем создаём ещё один контейнер в который копируем только скомпилированные ранее файлы ( js ), забираем только полезный код, из первого контейнера. 

#? 3) Запускаем второй контейнер в качестве конечного образа, так мы избежим копирования ненужных файлов в конечный образ, сделав его максимально лёгким.

#? Это также упростит процесс переключение между средами development / production
#*-----

#* Первый этап, собираем среду development.
# Определяем версию NODE для контейнера Docker
FROM node:18-alpine as development
# Определяем рабочую директорию
WORKDIR /usr/src/app
# Копируем файлы с описанием зависимостей
COPY package*.json .
# Устанавливаем зависимости в контейнер
RUN npm install
# Копируем все остальные файлы включая исходный код
COPY . .
# Делаем компиляцию кода из ts в js 
RUN npm run build

#* Второй этап, собираем среду production.

FROM node:18-alpine as production
# пара необязательных параметров
ARG NODE_ENV=production
ENV NODE_ENV=${NODE_ENV}
# Определяем рабочую директорию
WORKDIR /usr/src/app
# Копируем файлы с описанием зависимостей
COPY package*.json .
# Устанавливаем только зависимости ( dependencies ), так как все прочие зависимости в контейнере для ( production ) не нужны
RUN npm ci --only=production
# Копируем файлы ( js ) скомпилированные в первом контейнере.
COPY --from=development /usr/src/app/dist ./dist
# Определяем команду для запуска контейнера, команда node >>> в этом случае работает стабильнее для Docker, чем npm run >>>
CMD ["node", "dist/index.js"]